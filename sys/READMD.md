
## 开发目标
- [ ] 支持单核CPU.
- [ ] 支持一个简单的文件系统.
- [ ] 支持elf可执行文件格式.

## 内核中的重要数据结构
1. 进程管理:
    - 进程表. 使用一个固定大小的数组去管理进程.

2. 文件系统:
    - 磁盘块缓冲区. 记录在内存中缓存的磁盘块.
    - inode缓冲区. 记录在内存中缓存的inode.
    - file表. 记录系统中进程打开的文件列表.

## 思考
1. User模式trap到Kernel模式需要做什么?
   1. **保存用户态上下文.**

        那些必须保存的寄存器, 不同的架构需要保存的内容是不同的.
   
   2. **切换页表.**

        确定采用的方案是用户态进程和内核使用各自独立的页表, 这样对于多core的情况支持会更好一点, 因为在内核态时, 各个core可以都将页表的配置指针指向同一个地址, 这样不同的core就使用具有相同映射的虚拟地址空间了, 当这些core在访问需要保护的资源时加上锁就好了. 如果将虚拟地址空间分为内核和用户进程, 这样对多core的情况就不友好了, 因为每个core上运行的进程肯定是不同的, 这就要求每个core都需要将自己的页表配置指针指向不同的地址, 否则就会让多个进程的地址空间冲突, 这样切换到内核态的时候, 每个core还是在使用不同的页表, 这个时候加入有的进程需要建立一条页表映射, 这对其他进程是不可见的, 这会导致每个进程看到的内核地址空间都是不一样的. 但是反过来说, 第二种方式是不是也是一个好的选择呢? 进程结束的话就销毁它在内核态的地址空间. 先采用第一种分开的页表方案吧, 这个地方值得考虑.
        
        切换页表之后需要保证下一条指令能够正常执行. 怎么保证呢? 至少要保证下一条指令的地址在两个页表上有相同的映射, 即通过同一个va能找到同一个pa, 这个pa就是下一条指令的物理地址. 思考一下, cpu执行完切换页表的指令之后, pc指针"+1", 得到了下一条指令的地址, 这个地址需要经过新的页表去查询对应的pa.

    3. **切换到内核栈.**

        进程在用户态和内核态的栈是分开的.

    4. **切换trap处理函数.**

        因为现在已经处于内核态, 在内核态如果又发生了trap, 是不需要再去保存一次用户态的上下文的, 如果不改变trap在内核态是的入口, 那么一旦在内核态trap了, cpu还是会去之前的入口处去执行, 但是因为页表已经切换了, 它是找不到原来的trap处理函数的地址的, 结果就又trap了, 将一直循环下去; 就算它能找到原来的trap函数的入口, 那么再次执行的时候, 原来进程真正的上下文数据会被覆盖, 总而言之, 切换是必须要作的. 在执行内核态的trap处理函数时, 可以直接使用内核栈保存必要的上下文数据, 并在trap返回的时候恢复. 当用户进程trap到内核态, 我们说内核正在该用户进程的上下文中执行, 此时使用的内核栈从逻辑上是用户进程的一部分.

    5. **处理不同类型的trap.**

        可能是外设的中断, 定时器的中断, 用户进程的非法指令, 系统调用请求...等等.